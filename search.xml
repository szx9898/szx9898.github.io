<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>10.test</title>
      <link href="/2020/09/20/10.test/"/>
      <url>/2020/09/20/10.test/</url>
      
        <content type="html"><![CDATA[<h1 id="111"><a href="#111" class="headerlink" title="111"></a>111</h1><h2 id="222"><a href="#222" class="headerlink" title="222"></a>222</h2><p>3333</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM常用调参命令</title>
      <link href="/2020/08/05/9.JVM%E5%B8%B8%E7%94%A8%E8%B0%83%E5%8F%82%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/08/05/9.JVM%E5%B8%B8%E7%94%A8%E8%B0%83%E5%8F%82%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">调参命令</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">-Xms10m/-XX:InitialHeapSize</td><td align="left"><strong>堆区的起始内存</strong></td></tr><tr><td align="left">-Xmx10m/-XX:MaxHeapSize</td><td align="left"><strong>堆区的最大内存</strong></td></tr><tr><td align="left">-XX:NewRatio=2</td><td align="left"><strong>新生区与老年区占比，默认为2</strong></td></tr><tr><td align="left">-XX:SurvivorRatio=8</td><td align="left"><strong>Eden与s0/s1区比例，默认8:1:1</strong></td></tr><tr><td align="left">-XX:+PrintGCDetails</td><td align="left"><strong>打印GC过程的细节</strong></td></tr><tr><td align="left">-XX:-UseAdaptiveSizePolicy</td><td align="left"><strong>关闭自适应的内存分配策略</strong></td></tr><tr><td align="left">-Xmn500m</td><td align="left"><strong>设置新生代大小</strong></td></tr><tr><td align="left">-XX:+/-UseTLAB</td><td align="left"><strong>设置是否开启TLAB空间</strong></td></tr><tr><td align="left">-XX:+PrintFlagsInitial</td><td align="left"><strong>查看所有参数的默认初始值</strong></td></tr><tr><td align="left">-XX:+PrintFlagsFinal</td><td align="left"><strong>查看所有参数的最终值</strong></td></tr><tr><td align="left">jps查出进程号jinfo -flag  NewRatio 进程id</td><td align="left"><strong>具体查看某个参数的指令</strong></td></tr><tr><td align="left">-XX:HandlePromotionFailure</td><td align="left"><strong>是否设置空间分配担保</strong></td></tr><tr><td align="left">-XX:MaxTenuringThreshold</td><td align="left"><strong>设置新生代垃圾的最大年龄</strong></td></tr><tr><td align="left">-XX:MetaSpaceSize=100m</td><td align="left"><strong>设置元空间初始大小</strong></td></tr><tr><td align="left">-XX:+DoEscapeAnalysis</td><td align="left"><strong>开启逃逸分析(默认开启)</strong></td></tr><tr><td align="left">-XX:MetaSpaceSize=100m</td><td align="left"><strong>设置最大元空间大小</strong></td></tr><tr><td align="left">javap -v -p  XXX.class</td><td align="left"><strong>查看某个类的字节码信息</strong></td></tr><tr><td align="left">java -Xint -version/-Xint</td><td align="left"><strong>使用解释器</strong></td></tr><tr><td align="left">java -Xcomp -version/-Xcomp</td><td align="left"><strong>使用即时编译器</strong></td></tr><tr><td align="left">java -Xmixed -version/-Xmixed</td><td align="left"><strong>混合使用解释器和编译器</strong></td></tr><tr><td align="left">-XX:+HeapDumpOnOutOfMemoryError</td><td align="left"><strong>当出现OOM时会生成堆空间的dump文件</strong></td></tr><tr><td align="left">-XX:+PrintCommandLineFlags</td><td align="left"><strong>查看命令行相关参数(包含使用的垃圾回收器)</strong></td></tr><tr><td align="left">-XX:+UseConcMarkSweepGC</td><td align="left"><strong>使用ParNew垃圾收集器</strong></td></tr><tr><td align="left">-XX:ParallelGCThreads</td><td align="left"><strong>设置年轻代并行收集器的线程数，一般与CPU数相等</strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM&amp;GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GC </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收器(实现)</title>
      <link href="/2020/08/05/8.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8(%E5%AE%9E%E7%8E%B0)/"/>
      <url>/2020/08/05/8.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8(%E5%AE%9E%E7%8E%B0)/</url>
      
        <content type="html"><![CDATA[<h1 id="怎么选择垃圾回收器？"><a href="#怎么选择垃圾回收器？" class="headerlink" title="怎么选择垃圾回收器？"></a>怎么选择垃圾回收器？</h1><ol><li><p>优先调整堆的大小让JVM自适应完成。</p></li><li><p>如果内存小于10M，使用串行收集器</p></li><li><p>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</p></li><li><p>如果是多CPU、需要髙吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</p></li><li><p>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</p></li></ol><h1 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h1><p><strong>吞吐量/响应时间(矛盾)：</strong>运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p><p>吞吐量高了，垃圾收集次数就少了，收集次数少了意味着垃圾堆积导致每次GC的时间较长，也就会导致STW时间长</p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805142805.png" style="zoom:80%;" /><h1 id="7种垃圾回收器"><a href="#7种垃圾回收器" class="headerlink" title="7种垃圾回收器"></a>7种垃圾回收器</h1><p>串行回收器：Serial、Serial Old</p><p>并行回收器：ParNew、Parallel Scavenge、Parallel Old</p><p>并发收集器：CMS、G1</p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805142844.png" style="zoom:80%;" /><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805142849.png" style="zoom:80%;" /><ol><li><p>两个收集器间有连线，表明他们可以搭配使用：</p><p>Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Old、G1</p></li><li><p>其中Serial Old作为CMS出现”Concurrent Mode Failure”失败的后背预案</p></li><li><p>（红色虚线）由于维护和兼容性测试的成本，在JDK8时将 Serial+CMS、 ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9    中完全取消了这些组合的支持（JEP214），即：移除</p></li><li><p>（绿色虚线）JDK14中：弃用Parallel Scavenge和 Serial OldGC组合（JEP366）</p></li><li><p>（青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）</p><p><strong>对于交互性比较强的应用而言，串行垃圾收集器是不能接受的。一般Java Web应用程序中是不会采用串行垃圾收集器的</strong></p></li></ol><h2 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h2><p>​    <strong>吞吐量优先 ，响应慢，适合服务端</strong></p><ul><li>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</li><li>Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel 0ld收集器，用来代替老年代的 Serial Old收集器</li><li>Parallelold收集器采用了标记-压缩算法，但同样也是基于并行回收和Stop-the- World”机制。</li></ul><h2 id="CMS-Concurrent-Mark-Sweep"><a href="#CMS-Concurrent-Mark-Sweep" class="headerlink" title="CMS(Concurrent Mark Sweep)"></a>CMS(Concurrent Mark Sweep)</h2><p>​    <strong>低延迟的并发收集器，响应快</strong>，使用的是标记-清除算法</p><p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805145019.png" alt=""></p><p>​    CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。</p><p>​    初始标记（ Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p><ul><li>并发标记（Concurrent-Mark）阶段：从 GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li>重新标记（ Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li>并发清除（concurrent- Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li></ul><p><strong>为什么CMS不使用标记-压缩算法？</strong></p><p>​    答案其实很简答，因为当并发清除的时候，用 Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。 Mark Compact更适合“ Stop the World”这种场景下使用</p><p><strong>优点：</strong>并发收集、低延迟</p><p><strong>缺点：</strong>会产生内存碎片、对CPU资源非常敏感总吞吐量降低、无法处理浮动垃圾(在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收)</p><h2 id="G1回收器"><a href="#G1回收器" class="headerlink" title="G1回收器"></a>G1回收器</h2><p>​    <strong>区域分代化</strong>，由于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会尝试对GC进行优化。G1(Garbage-First)垃圾回收器是在Java7 Update 4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一</p><p><strong>G1的目标：</strong>在延迟可控的情况下获得尽可能高的吞吐量，所以才担任起“全功能收集器的功能”的重任与期望</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>1.并行与并发：</strong></p><ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li><li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><p><strong>2.分代收集：</strong></p><ul><li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和 Survivor区。但从堆的结构上看，它不要求整个Edeh区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将堆空间分为若干个区域（ Region），这些区域中包含了逻辑上的年轻代和老年代。</li><li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul><p><strong>3.空间整合：</strong></p><ul><li>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li><li>G1将内存划分为一个个的 region。内存的回收是以 region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark- Compact算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ul><p><strong>4.可预测的停顿时间模型：</strong></p><p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M亳秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒</p><ul><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1跟踪各个 Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于CMS GC，G1未必能做到cMs在最好情况下的延时停顿，但是最差情况要好很多。</li></ul><p><strong>参数设置：</strong></p><p>-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务。</p><p>-XX:G1HeapRegionSize 设置每个 Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</p><p>-XX:MaxGCPauseMillis 设置期望达到的最大GC停顿时间指标（JⅥM会尽力实现，但不保证达到）。默认值是200ms</p><p>-XX:ParallelGCThread 设置STW工作线程数的值。最多设置为8</p><p>-XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。</p><p>-XX:InitiatingHeapOccupancyPercent  设置触发并发GC周期的Jav堆占用率阈值。超过此值，就触发GC。默认值是45。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p></li><li><p>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</p><ul><li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的 Region的增量式清理来保证每次GC停顿时间不会过长）。</li></ul></li><li><p>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：</p><ul><li>超过50%的Java堆被活动数据占用；</li><li>对象分配频率或年代提升频率变化很大</li><li>GC停顿时间过长（长于8.5至1秒）。</li></ul></li><li><p>Hotspot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p></li></ul><h3 id="分区Region：化整为零"><a href="#分区Region：化整为零" class="headerlink" title="分区Region：化整为零"></a>分区Region：化整为零</h3><p>​    使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立 Region块，每个 Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过ⅩX:G1HeapRegionsize设定。所有的 Region大小相同，且在JVM生命周期内不会被改变。</p><p>​    虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了它们都是一部分 Region（不需要连续）的集合。通过 Region的动态分配方式实现逻辑上的连续。</p><p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805150027.png" alt=""></p><ul><li><p>一个region可能属于Eden，Survivor或者Old区，可转换</p></li><li><p>G1垃圾收集器还增加了一种新的内存区域，叫做 Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region,就放到H</p><ul><li>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个 Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动FullGC.G1的大多数行为都把H区作为老年代的一部分来看待。</li></ul></li></ul><h3 id="G1垃圾回收过程"><a href="#G1垃圾回收过程" class="headerlink" title="G1垃圾回收过程"></a>G1垃圾回收过程</h3><p>​    应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到 Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p><p>​    当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程</p><p>​    标记完成马上开始混合回收过程。对于一个混合回收期，G1GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收小部分老年代的 Region就可以了。同时，这个老年代 Region是和年轻代一起被回收的。</p><p><strong><em>Remembered Set</em></strong></p><p>​    因为Region区不是孤立的，可能存在相互引用，若E区对象引用另一个E区对象还好，只需要YoungGC，但是若Old区引用Eden区，不仅要YoungGC还要遍历老年代，这是区域化的一个弊端，会降低MinorGC的效率</p><p>​    <strong>解决办法：</strong>每个Region都有一个对应的Remembered Set，检查存在引用类型是否与本块相同，不同则记录到Remembered Set中，当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set，就可以保证不进行全局扫描，也不会有遗漏</p><h4 id="阶段一：年轻代GC"><a href="#阶段一：年轻代GC" class="headerlink" title="阶段一：年轻代GC"></a>阶段一：年轻代GC</h4><p>​    JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。<br>​    年轻代垃圾回收只会回收Eden区和 Survivor区。<br>​    YGC时，首先G1停止应用程序的执行（stop-The-Mor1d），G1创建回收集（collection set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和 Survivor区所有的内存分段。</p><h4 id="阶段二：并发标记过程"><a href="#阶段二：并发标记过程" class="headerlink" title="阶段二：并发标记过程"></a>阶段二：并发标记过程</h4><ol><li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。</li><li>根区域扫描（ Root Region Scanning）：G1GC扫描 Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 young GC之前完成。</li><li>并发标记（ Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）</li><li>再次标记（ Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at- the-beginning（SATB）。</li><li>独占清理（ cleanup,sTw）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。<ul><li>这个阶段并不会实际上去做垃圾的收集</li></ul></li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ol><h4 id="阶段三：混合回收"><a href="#阶段三：混合回收" class="headerlink" title="阶段三：混合回收"></a>阶段三：混合回收</h4><p>​    当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed gc，该算法并不是一个0ld GC，除了回收整个 Young Region，还会回收一部分的Old region。<strong>这里需要注意：是一部分老年代，而不是全部老年代</strong>。可以选择哪些old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 <strong>Mixed GC并不是FullGC</strong></p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805151057.png" style="zoom:67%;" /><ul><li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过XX：G1MixedGCCountTarget设置）被回收。</li><li>混合回收的回收集（collection set）包括八分之一的老年代内存分段，Eden区内存分段， Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li><li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。<strong>垃圾占内存分段比例越高的，越会被先回收</strong>。并且有一个阈值会决定内存分段是否被回收， XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li><li>混合回收并不一定要进行8次。有一个阈值-XX:G1 HeapwastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li></ul><h4 id="可选阶段四：Full-GC"><a href="#可选阶段四：Full-GC" class="headerlink" title="可选阶段四：Full GC"></a>可选阶段四：Full GC</h4><p>原因：1.内存空间不足；2.并发处理完成之前空间耗尽</p><h3 id="G1回收器优化建议"><a href="#G1回收器优化建议" class="headerlink" title="G1回收器优化建议"></a>G1回收器优化建议</h3><ul><li>年轻代大小<ul><li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖暂停时间目标</li></ul></li><li>暂停时间目标不要太过严苛<ul><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM&amp;GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StringTable</title>
      <link href="/2020/08/05/7.StringTable/"/>
      <url>/2020/08/05/7.StringTable/</url>
      
        <content type="html"><![CDATA[<p><strong>-XX:+PrintStringTableStatistics 打印StringTable信息</strong></p><p><strong>jdk1.6之前，有永久代，静态变量存放在永久代</strong></p><p><strong>jdk1.7，有永久代，把字符串常量池和静态变量放在了堆中</strong></p><p><strong>jdk1.8，无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆，逻辑仍存在于方法区</strong></p><h1 id="为什么不用永久代？"><a href="#为什么不用永久代？" class="headerlink" title="为什么不用永久代？"></a>为什么不用永久代？</h1><p>1.为永久代设置空间大小很难确定</p><p>2.对永久代进行调优困难</p><h1 id="StringTable为什么要调整？"><a href="#StringTable为什么要调整？" class="headerlink" title="StringTable为什么要调整？"></a>StringTable为什么要调整？</h1><p>​    Stringtable在永久代回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存</p><p><strong>字符串常量池不会存储相同内容的字符串：</strong></p><ul><li>String的 StringPool是一个固定大小的 Hashtab1e，默认值大小长度是1009.如果放进 String pool的 string非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用string. intern时性能会大幅下降。</li><li>使用-XX:StringTableSize可设置 StringTable的长度</li><li>jdk6中 StringTable是固定的，就是1009的长度，所以如果常量池中在的字符串过多就会导致效率下降很快。 stringTableSize设置没有要求</li><li>在jdk7中， StringTable的长度默认值是60013,1009是可设置的最小值</li><li>Jdk8开始，设置 stringTable的长度的话，1009是可设置的最小值</li></ul><h1 id="字符串的位置"><a href="#字符串的位置" class="headerlink" title="字符串的位置"></a>字符串的位置</h1><ul><li><p>Java6及以前，字符串常量池存放在永久代</p></li><li><p>Java7中 oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内。</p></li><li><ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java7中使用 <code>string.intern()</code></li></ul></li><li><p>Java8元空间，字符串常量在堆</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">"a"</span>;</span><br><span class="line">    String s2 = <span class="string">"b"</span>;</span><br><span class="line">    String s3 = <span class="string">"ab"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 细节：</span></span><br><span class="line"><span class="comment">     *  1.StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">     *  2.s.append("a");</span></span><br><span class="line"><span class="comment">     *  3.s.append("b");</span></span><br><span class="line"><span class="comment">     *  4.s.toString();---&gt;类似于new String("ab");</span></span><br><span class="line"><span class="comment">     *  5.左右两边是变量底层才会使用StringBuilder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String s4 = s1 + s2;</span><br><span class="line">    System.out.println(s3==s4);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="new-String-“ab”-会创建几个对象？"><a href="#new-String-“ab”-会创建几个对象？" class="headerlink" title="new String(“ab”)会创建几个对象？"></a>new String(“ab”)会创建几个对象？</h1><p>2个。    </p><ol><li><p>new关键字在堆中创建的。</p></li><li><p>字符串常量池中的对象”ab”。 字节码指令：ldc</p></li></ol><h1 id="new-String-“a”-new-String-“b”-呢？"><a href="#new-String-“a”-new-String-“b”-呢？" class="headerlink" title="new String(“a”)+new String(“b”)呢？"></a>new String(“a”)+new String(“b”)呢？</h1><p>对象1：new StringBuilder()</p><p>对象2：new String(“a”)</p><p>对象3：常量池中的”a”</p><p>对象4：new String(“b”)</p><p>对象5：常量池中的”b”</p><p>深入剖析：StringBuilder的toString()</p><p>对象6：new String(“ab”)</p><p>强调：toString()的使用，在字符串常量池中没有生成”ab”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">    s1.intern();<span class="comment">//调用此方法前，字符串常量池中已存在"1"</span></span><br><span class="line">    String s2 = <span class="string">"1"</span>;<span class="comment">//此时的1是new String("1")放在字符串常量池的"1"</span></span><br><span class="line">    System.out.println(s1 == s2);<span class="comment">//jdk6:false jdk7/8:false</span></span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);<span class="comment">//s3变量记录的地址为：new String("11")</span></span><br><span class="line">    <span class="comment">//执行完上一行代码之后字符串常量池中没有"11"</span></span><br><span class="line">    s3.intern();</span><br><span class="line">    <span class="comment">//jdk6:在字符串常量池中创建新对象"11"</span></span><br><span class="line">    <span class="comment">//jdk7/8:在字符串常量池创建一个指向堆空间new String("11")的地址</span></span><br><span class="line">    String s4 = <span class="string">"11"</span>;<span class="comment">//s4变量记录的地址：上一行代码中生成的"11"</span></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//jdk6:false jdk7/8:true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">    String s2 = s1.intern();</span><br><span class="line">    System.out.println(s1 == s2);<span class="comment">//jdk6:false jdk7/8:true</span></span><br><span class="line">    System.out.println(s1 == <span class="string">"ab"</span>);<span class="comment">//jdk6:false jdk7/8:true</span></span><br><span class="line">    System.out.println(s2 == <span class="string">"ab"</span>);<span class="comment">//jdk6:true jdk7/8:true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于程序中大量存在的字符串，尤其其中存在很多重复字符串时，使用 intern()可以节省内存空间。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM&amp;GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM层面解释对象的创建</title>
      <link href="/2020/08/05/6.JVM%E5%B1%82%E9%9D%A2%E8%A7%A3%E9%87%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>/2020/08/05/6.JVM%E5%B1%82%E9%9D%A2%E8%A7%A3%E9%87%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805104048.png" alt="对象实例化"></p><hr><h1 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h1><h2 id="加载类元信息"><a href="#加载类元信息" class="headerlink" title="加载类元信息"></a>加载类元信息</h2><p>​    虚拟机遇到一条new指令，首先去检查这个指令的参数能否在MetaSpace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、链接和初始化(即判断类的原信息是否存在)。没有则通过双亲委派机制使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到。则进行类加载，生成对应的Class对象</p><h2 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h2><p>​    首先计算对象占用空间大小，再在堆中划分一块内存给新对象，如果实例变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p><ul><li><p><strong>内存规整—&gt;指针碰撞</strong></p><p>如果内存是规整的，那么虛拟机将采用的是指针碰撞法（ Bump The Pointer）来为对象分配内存</p><p>意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是 Serial、 ParDew这种基于压缩算法的，虛拟机采用这种分配方式。一般使用带有compact（整理）过程的收集器时，使用指针碰撞</p></li><li><p><strong>内存不规整—&gt;虚拟机需要维护一个列表/空闲列表分配</strong></p><p>如果内存不规整，虚拟机采用空闲列表法来为对象分配内存，虚拟机维护了一个列表，记录了哪些内存可用，哪些不可用，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容，这种分配方式称为”空闲列表（Free List）”</p></li><li><p><strong>说明</strong></p><p>选择哪种分配方式是由Java堆是否规整决定的，而Java堆是否规整又是由所采取的垃圾回收器是否带有压缩整理功能决定的</p></li></ul><h2 id="处理并发安全问题"><a href="#处理并发安全问题" class="headerlink" title="处理并发安全问题"></a>处理并发安全问题</h2><ul><li>采用CAS失败重试、区域加锁保证更新的原子</li><li>每个线程预先分配TLAB（缓存共享资源）-&gt;&gt;-XX:+/-UseTLAB设置(默认使用) ，关于TLAB详看之前我写的<a href="https://zzxxrr.com/2020/08/04/JVM结构概述/">JVM结构概述</a></li></ul><h2 id="属性默认初始化-零值初始化"><a href="#属性默认初始化-零值初始化" class="headerlink" title="属性默认初始化(零值初始化)"></a>属性默认初始化(零值初始化)</h2><h2 id="设置对象头信息"><a href="#设置对象头信息" class="headerlink" title="设置对象头信息"></a>设置对象头信息</h2><p>​    将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中，这个过程的具体设置方式取决于JVM实现</p><h2 id="执行init方法进行初始化"><a href="#执行init方法进行初始化" class="headerlink" title="执行init方法进行初始化"></a>执行init方法进行初始化</h2><p>属性显式初始化、代码块中初始化、构造器中初始化</p><hr><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805110010.png" alt="内存布局"></p><p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805110041.png" alt="创建对象时JVM所做的事"></p><hr><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><h2 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h2><p>一个对象对应一个句柄，一个句柄包括对象实例数据以及类型数据的指针</p><p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805110328.png" alt="句柄访问"></p><h2 id="直接指针-HotSpot采用"><a href="#直接指针-HotSpot采用" class="headerlink" title="直接指针(HotSpot采用)"></a>直接指针(HotSpot采用)</h2><p>一个对象直接指向对象实例数据，实例数据包括类型数据的指针</p><p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805110413.png" alt="直接指针"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM&amp;GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM结构概述</title>
      <link href="/2020/08/04/5.JVM%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/08/04/5.JVM%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200804161220.png" alt="JVM结构图" style="zoom:67%;" /><hr><h1 id="类装载器子系统"><a href="#类装载器子系统" class="headerlink" title="类装载器子系统"></a>类装载器子系统</h1><p><strong>类加载子系统</strong>包括加载(4种类加载器)、链接(verify、prepare、resolve)、初始化的过程</p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200804161542.png" alt="链接阶段" style="zoom: 67%;" /><p>​    <strong>初始化阶段</strong>就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程，此方法不需要定义，是javac编译器自动收集类中的所有静态变量的赋值动作和静态代码块中的语句合并而来的，其实就是只要有静态变量，就会有<code>&lt;clinit&gt;()</code>的过程，如果父类有静态变量，则会先加载父类的<code>&lt;clinit&gt;()</code>，虚拟机必须保证一个类<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p><p>​    <strong>类加载器</strong>：BootstrapClassLoader(C++实现)、ExtensionClassLoader(Java实现)、ApplicationClassLoader(Java实现)、还有用户自定义的，这四者关系是包含关系，不是上下层。Java的核心类库都是使用引导类加载器进行加载的。<br>方法区和堆是线程共享的(单线程)，其他是线程私有的(多线程)</p><h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>​    Register的命名来源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。<br>​    <strong>作用：</strong>用来存储指向下一条指令的地址，还有即将要执行的指令代码。由执行引擎读取下一条指令，CPU需要不停地切换各个线程，当切换到某个线程时，需要知道从哪里开始执行，使执行引擎明确下一条该执行什么样的字节码指令。</p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200804162131.png" alt="程序计数器" style="zoom: 67%;" /><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>​    每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)，一个栈帧对应一个方法，生命周期和线程一致<br>​    <strong>特点：</strong>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令，对于栈来说不发生GC可能发生OOM<br>​    <strong>作用：</strong>主管Java程序的运行，它保存方法的局部变量(8种基本数据类型、对象的引用地址)、 部分结果，并参与方法的调用和返回<br>当Java虚拟机栈是固定大小时，线程请求分配栈容量大于固定大小，会发生StackOverflowError异常<br>如果虚拟机栈是动态扩展的，并在扩展时无法申请到足够的内存，会抛出OutOfMemoryError异常</p><h3 id="局部变量表-Local-Variables"><a href="#局部变量表-Local-Variables" class="headerlink" title="局部变量表(Local Variables)"></a>局部变量表(Local Variables)</h3><ul><li>定义一个数字数组，存储基本数据类型和对象引用以及returnAddress，最基础的存储单元是Slot（变量槽）</li></ul><ul><li>32位以内的类型只占用一个slot(returnAddress类型)，64位类型(long和double)占用两个slot。byte、short、char、boolean存储前转    化为int，其中boolean0表    示false，非0表示true，long和double占据两个Slot</li><li>如果当前栈帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index[0]的slot处</li><li>栈帧中的局部变量表中的槽位是可以重复利用的，可以节约资源</li><li>成员变量(类变量、实例变量)可以不需要初始化赋值，局部变量必须初始化赋值</li></ul><h3 id="操作数栈-Operand-Stack-表达式栈"><a href="#操作数栈-Operand-Stack-表达式栈" class="headerlink" title="操作数栈(Operand Stack,表达式栈)"></a>操作数栈(Operand Stack,表达式栈)</h3><ul><li>底层是数组实现，主要保存计算过程中间结果，同时作为计算过程中变量临时的存储空间</li><li>虽然是数组实现，但只能通过push/pop操作完成数据访问</li><li>如果被调用方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈，并更新PC寄存器中下一条指令的字节码指令</li></ul><h3 id="动态链接-Dynamic-Linking"><a href="#动态链接-Dynamic-Linking" class="headerlink" title="动态链接(Dynamic Linking)"></a>动态链接(Dynamic Linking)</h3><p>​    也可以称为指向运行时常量池的方法引用</p><ul><li>运行时常量池在方法区</li><li>常量池的作用，就是为了提供一些符号和常量，便于指令的识别</li></ul><h3 id="方法返回地址-Return-Address"><a href="#方法返回地址-Return-Address" class="headerlink" title="方法返回地址(Return Address)"></a>方法返回地址(Return Address)</h3><p>​    也是方法正常退出或者异常退出的定义</p><ul><li>存放调用该方法的pc寄存器的值</li><li>通过异常完成退出的不会给上层调用者产生任何返回值</li><li>返回指令包含 ireturn（当返回值是 boolean、byte、char、 short和int类型时使用）lreturn、 freturn、 dreturn以及 areturn，另外还有一个 return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</li></ul><h3 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h3><hr><p>​    Java是静态类型语言，在jdk1.8引入lambda具备了一些静态语言特点String str = ‘111’，Python和JS是动态类型语言str = 11，静态类型语言就是判断变量的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息 </p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>​    本地方法栈用于管理本地方法的调用，是线程私有的<br>​    并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求木地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持 native方法，也可以无需实现本地方法栈。<br>​    当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。在 Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>​    可以物理上不连续的内存空间，在逻辑上它被认为是连续的，所有的线程共享堆，在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer,TLAB)，TLAB占据Eden区的1%。<br>​    默认堆空间初始大小是物理内存的1/64,堆空间最大内存是物理内存的1/4,开发中建议将这两个值设置成一样的</p><h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><p>​    JVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB（Thread-local allocation buffer）。默认设定为占用Eden Space的1%。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。</p><p>​    也就是说，Java中每个线程都会有自己的缓冲区称作TLAB（Thread-local allocation buffer），每个TLAB都只有一个线程可以操作，TLAB结合指针碰撞(bump-the-pointer)技术可以实现快速的对象分配，而不需要任何的锁进行同步，也就是说，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。</p><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><ul><li><p>Eden、SurvivorFrom 复制到 SurvivorTo，年龄+1</p><ul><li>Eden区满了会发生第一次GC，活着的到SurvivorFrom区，当Eden区再满了，在Eden和SurvivorFrom区发生GC，幸存者到SurvivorTo区(如果有对象到了老年标准，则赋值到老年区)，同时年龄+1</li></ul></li><li><p>清空 eden、SurvivorFrom</p><ul><li>清空Eden和SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to</li></ul></li><li><p>SurvivorTo和 SurvivorFrom 互换</p><ul><li>SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区。部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代</li></ul></li></ul><p>MajorGC：老年代满了会触发，大对象会直接放到老年代</p><p>FulGC：对整个堆空间进行GC</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>​    当变量只定义在方法中并且只在方法中作用，则此对象没有发生逃逸，可以分配到栈上，随着方法执行的结束，栈空间就被移除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringBuffer发生逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的代码如果想要StringBuffer不逃出方法，可以这样写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><ul><li>方法区（ Method area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang. OutofMemoryerror：PermGen space 4 java. lang. OutofMemoryError:Metaspace</li><li>关闭JVM就会释放这个区域的内存。</li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul><li><p>运行时常量池（ Runtime Constant pool）是方法区的一部分。</p></li><li><p>常量池表（ Constant pool Table）是 Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p></li><li><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p></li><li><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p></li><li><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p><ul><li>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</li></ul></li><li><p>运行时常量池类似于传统编程语言中的符号表（ symbol table），但是它所包含的数据却比符号表要更加丰富一些。</p></li><li><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM 抛出OutofMemoryError异常。</p></li></ul><p><strong><em>jdk1.6之前，有永久代，静态变量存放在永久代<br>jdk1.7，有永久代，把字符串常量池和静态变量放在了堆中<br>jdk1.8，无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆，逻辑仍存在于方法区</em></strong></p><p><strong>为什么不用永久代？</strong></p><ul><li><p>为永久代设置空间大小很难确定</p></li><li><p>对永久代进行调优困难</p></li></ul><p><strong>StringTable为什么要调整？</strong></p><p>​     Stringfable在永久代回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存</p><p><strong>方法区的垃圾回收：可有可无，HotSpot有</strong></p><p>​    有些人认为方法区（如 Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）</p><p>​    一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的 Hotspot虚拟机对此区域未完全回收而导致内存泄漏。</p><p>​    方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型</p><h1 id="本地方法库-本地方法接口"><a href="#本地方法库-本地方法接口" class="headerlink" title="本地方法库/本地方法接口"></a>本地方法库/本地方法接口</h1><p>​    一个Native Method就是一个Java调用非Java代码接口</p><h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><p>​    JVM的主要任务是负责装载字节码文件到内部，但字节码指令不是本地机器指令所以无法直接运行在操作系统上，字节码的内部仅仅包含一些能被JVM所识别的字节码指令、符号表以及其他辅助信息，<strong>执行引擎的作用是将字节码指令解释/编译(不是.java变成.class)成机器指令使底层操作系统识别。</strong></p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200804172040.png" alt="执行引擎" style="zoom:67%;" /><ol><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后， PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ol><p><strong>javac前端编译器的过程（不涉及JVM虚拟机，只是生成.class字节码文件的过程）：</strong></p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200804172315.png" style="zoom: 80%;" /><p><strong>执行引擎干的事情：</strong></p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200804172349.png" style="zoom: 67%;" /><p>​    <strong>Java是半编译型半解释型语言：</strong>执行引擎在解释执行字节码文件，让CPU操作系统执行指令的时候既可以使用解释器，也可以使用即时编译器(后端编译器)</p><p>​    <strong>解释器：</strong>对字节码采用逐行解释的方式执行，将每条字节码文件中的内容”翻译”成对应平台的本地机器指令执行<strong>(直接解释执行，侧重于执行)</strong></p><p>​    <strong>JIT即时编译器：</strong>将字节码直接编译成和本地机器平台相关的机器语言，并且可以将JIT编译的后的机器指令在方法区进行缓存<strong>(编译成机器指令进行缓存，侧重于编译缓存)</strong></p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200804172216.png" alt="" style="zoom:67%;" /><p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200804172648.png" alt="JIT即时编译器"></p><p>BEA的JRockit不含解析器，全靠即时编译器实现，08年被oracle公司收购，世界上最块的JVM，专注于服务端</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM&amp;GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈无状态和有状态登录</title>
      <link href="/2020/08/01/4.%E6%B5%85%E8%B0%88%E6%97%A0%E7%8A%B6%E6%80%81%E5%92%8C%E6%9C%89%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95/"/>
      <url>/2020/08/01/4.%E6%B5%85%E8%B0%88%E6%97%A0%E7%8A%B6%E6%80%81%E5%92%8C%E6%9C%89%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="有状态"><a href="#有状态" class="headerlink" title="有状态"></a>有状态</h1><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如tomcat中的session。例如登录：用户登录后，我们把登录者的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session。然后下次请求，用户携带cookie值来，我们就能识别到对应session，从而找到用户的信息。</p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200730173720.png" alt="有状态登录流程" style="zoom:67%;" /><p><strong>缺点是什么？</strong></p><ol><li><p>服务端保存大量数据，增加服务端压力</p></li><li><p>服务端保存用户状态，无法进行水平扩展</p></li><li><p>客户端请求依赖服务端，多次请求必须访问同一台服务器</p></li></ol><p>在<strong>负载均衡</strong>方面，在有状态的模式下，一个用户的请求必须被提交到保存有其相关状态信息的服务器上，否则这些请求可能无法被理解，这也就意味着在此模式下服务器端无法对用户请求进行自由调度。于此相关的另一个问题是<strong>容错性</strong>，倘若保有用户信息的服务器宕机，那么该用户最近的所有交互操作将无法被透明地移送至备用服务器上，除非该服务器时刻与主服务器同步全部用户的状态信息。</p><h1 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h1><p>微服务集群中的每个服务，对外提供的都是Rest风格的接口。而Rest风格的一个最重要的规范就是：服务的无状态性，即：</p><ul><li><p>服务端不保存任何客户端请求者信息</p></li><li><p>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</p></li></ul><p><strong>带来的好处是什么呢？</strong></p><ol><li><p>客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务</p></li><li><p>服务端的集群和状态对客户端透明</p></li><li><p>服务端可以任意的迁移和伸缩</p></li><li><p>减小服务端存储压力</p></li></ol><h1 id="如何实现无状态"><a href="#如何实现无状态" class="headerlink" title="如何实现无状态"></a>如何实现无状态</h1><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200730174055.png" alt="Token实现无状态登录" style="zoom: 80%;" /><p>无状态登录的流程：</p><ol><li><p>当客户端第一次请求服务时，服务端对用户进行信息认证（登录）</p></li><li><p>认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证</p></li><li><p>以后每次请求，客户端都携带认证的token</p></li><li><p>服务器对token进行解密，判断是否有效并返回用户信息。</p></li></ol><p>生成Token的标准可以是JWT。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200731090950.png" alt="JWT组成" style="zoom:80%;" /><p>JWT包含三部分数据：</p><ul><li><p>Header：头部，通常头部有两部分信息：</p><ul><li>token类型：JWT</li><li>加密方式：base64（HS256）</li></ul></li><li><p>Payload：载荷，就是有效数据，一般包含下面信息：</p><ul><li>用户身份信息（注意，这里因为采用base64编码，可解码，因此不要存放敏感信息）</li><li>注册声明：如token的签发时间，过期时间，签发人等</li></ul><p>这部分也会采用base64编码，得到第二部分数据</p></li><li><p>Signature：签名，是整个数据的认证信息。根据前两步的数据，再加上指定的密钥（secret）（不要泄漏，最好周期性更换），通过base64编码生成。用于验证整个数据完整和可靠性</p></li></ul><p>因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，完全符合了Rest的无状态规范。</p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200731091642.png" alt="JWT数据组成" style="zoom:67%;" /><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>加密技术是对信息进行编码和解码的技术，编码是把原来可读信息（又称明文）译成代码形式（又称密文），其逆过程就是解码（解密），加密技术的要点是加密算法，加密算法可以分为三类： </p><ul><li><p>对称加密，如AES</p><ul><li><p>基本原理：将明文分成N个组，然后使用密钥对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。</p></li><li><p>优势：算法公开、计算量小、加密速度快、加密效率高</p></li><li><p>缺陷：双方都使用同样密钥，安全性得不到保证</p></li></ul></li><li><p>非对称加密，如RSA</p><ul><li>基本原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端<ul><li>私钥加密，持有公钥才可以解密</li><li>公钥加密，持有私钥才可解密</li></ul></li><li>优点：安全，难以破解</li><li>缺点：算法比较耗时</li></ul></li><li><p>不可逆加密，如MD5，SHA</p><ul><li>基本原理：加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文，这种加密后的数据是无法被解密的，无法根据密文推算出明文。</li></ul></li></ul><p>RSA算法历史：</p><p>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字缩写：RSA</p><h2 id="RS256"><a href="#RS256" class="headerlink" title="RS256"></a>RS256</h2><p>JWT签名算法中，一般有两个选择，一个采用HS256,另外一个就是采用RS256。</p><p>签名实际上是一个加密的过程，生成一段标识（也是JWT的一部分）作为接收方验证信息是否被篡改的依据。RS256 (采用SHA-256 的RSA 签名) 是一种非对称算法, 它使用公共/私钥对: 标识提供方采用私钥生成签名, JWT 的使用方获取公钥以验证签名。由于公钥 (与私钥相比) 不需要保护, 因此大多数标识提供方使其易于使用方获取和使用 (通常通过一个元数据URL)。</p><p>另一方面, HS256 (带有 SHA-256 的 HMAC 是一种对称算法, 双方之间仅共享一个 密钥。由于使用相同的密钥生成签名和验证签名, 因此必须注意确保密钥不被泄密。</p><p>在开发应用的时候启用JWT，使用RS256更加安全，你可以控制谁能使用什么类型的密钥。另外，如果你无法控制客户端，无法做到密钥的完全保密，RS256会是个更佳的选择，JWT的使用方只需要知道公钥。</p><p>由于公钥通常可以从元数据URL节点获得，因此可以对客户端进行进行编程以自动检索公钥。如果采用这种方式，从服务器上直接下载公钥信息，可以有效的减少配置信息。</p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200731102725.png" alt="JWT Authentication Workflow with RSA" style="zoom:80%;" /><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200731103025.png" alt="JWT Authentication for multiple susbsytems" style="zoom:80%;" /><h2 id="Code实现"><a href="#Code实现" class="headerlink" title="Code实现"></a>Code实现</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jwt:</span></span><br><span class="line">  <span class="attr">info:</span></span><br><span class="line">    <span class="attr">pubKeyPath:</span> <span class="string">D:\\rsa\\rsa.pub</span> <span class="comment"># 公钥地址</span></span><br><span class="line">    <span class="attr">priKeyPath:</span> <span class="string">D:\\rsa\\rsa.pri</span> <span class="comment"># 私钥地址</span></span><br><span class="line">    <span class="attr">secret:</span> <span class="string">sf3423jsdf#3$@FDS32</span></span><br><span class="line">    <span class="attr">expire:</span> <span class="number">180</span> <span class="comment"># 过期时间,单位分钟</span></span><br><span class="line">    <span class="attr">cookieName:</span> <span class="string">JWT_TOKEN</span></span><br></pre></td></tr></table></figure><h3 id="JWT相关工具类"><a href="#JWT相关工具类" class="headerlink" title="JWT相关工具类"></a>JWT相关工具类</h3><h4 id="JwtProperties"><a href="#JwtProperties" class="headerlink" title="JwtProperties"></a>JwtProperties</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"jwt.info"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String secret; <span class="comment">// 密钥</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pubKeyPath;<span class="comment">// 公钥</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String priKeyPath;<span class="comment">// 私钥</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expire;<span class="comment">// token过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cookieName; <span class="comment">// cookie名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PublicKey publicKey; <span class="comment">// 公钥</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PrivateKey privateKey; <span class="comment">// 私钥</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@PostContruct</span>：在构造方法执行之后执行该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File pubKey = <span class="keyword">new</span> File(pubKeyPath);</span><br><span class="line">            File priKey = <span class="keyword">new</span> File(priKeyPath);</span><br><span class="line">            <span class="keyword">if</span> (!pubKey.exists() || !priKey.exists()) &#123;</span><br><span class="line">                <span class="comment">// 生成公钥和私钥</span></span><br><span class="line">                RsaUtils.generateKey(pubKeyPath, priKeyPath, secret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取公钥和私钥</span></span><br><span class="line">            <span class="keyword">this</span>.publicKey = RsaUtils.getPublicKey(pubKeyPath);</span><br><span class="line">            <span class="keyword">this</span>.privateKey = RsaUtils.getPrivateKey(priKeyPath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"初始化公钥和私钥失败！"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JwtUtils"><a href="#JwtUtils" class="headerlink" title="JwtUtils"></a>JwtUtils</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥加密token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map           载荷中的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireMinutes 过期时间，单位秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateToken</span><span class="params">(Map&lt;String, Object&gt; map, PrivateKey key, <span class="keyword">int</span> expireMinutes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setClaims(map)</span><br><span class="line">                .setExpiration(DateTime.now().plusMinutes(expireMinutes).toDate())</span><br><span class="line">                .signWith(key, SignatureAlgorithm.RS256)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥解析token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token  用户请求中的token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Jws&lt;Claims&gt; <span class="title">parserToken</span><span class="params">(String token, PublicKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser().setSigningKey(key).parseClaimsJws(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token中的用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token  用户请求中的令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">getInfoFromToken</span><span class="params">(String token, PublicKey key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = parserToken(token, key);</span><br><span class="line">        <span class="keyword">return</span> claimsJws.getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RsaUtils"><a href="#RsaUtils" class="headerlink" title="RsaUtils"></a>RsaUtils</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RsaUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从文件中读取公钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filename 公钥保存路径，相对于classpath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公钥对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">getPublicKey</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = readFile(filename);</span><br><span class="line">        <span class="keyword">return</span> getPublicKey(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从文件中读取密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filename 私钥保存路径，相对于classpath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 私钥对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">getPrivateKey</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = readFile(filename);</span><br><span class="line">        <span class="keyword">return</span> getPrivateKey(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取公钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 公钥的字节形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">getPublicKey</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        X509EncodedKeySpec spec = <span class="keyword">new</span> X509EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory factory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        <span class="keyword">return</span> factory.generatePublic(spec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 私钥的字节形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">getPrivateKey</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PKCS8EncodedKeySpec spec = <span class="keyword">new</span> PKCS8EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory factory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        <span class="keyword">return</span> factory.generatePrivate(spec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据密文，生存rsa公钥和私钥,并写入指定文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKeyFilename  公钥文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKeyFilename 私钥文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secret             生成密钥的密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchAlgorithmException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateKey</span><span class="params">(String publicKeyFilename, String privateKeyFilename, String secret)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom(secret.getBytes());</span><br><span class="line">        keyPairGenerator.initialize(<span class="number">2048</span>, secureRandom);</span><br><span class="line">        KeyPair keyPair = keyPairGenerator.genKeyPair();</span><br><span class="line">        <span class="comment">// 获取公钥并写出</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicKeyBytes = keyPair.getPublic().getEncoded();</span><br><span class="line">        writeFile(publicKeyFilename, publicKeyBytes);</span><br><span class="line">        <span class="comment">// 获取私钥并写出</span></span><br><span class="line">        <span class="keyword">byte</span>[] privateKeyBytes = keyPair.getPrivate().getEncoded();</span><br><span class="line">        writeFile(privateKeyFilename, privateKeyBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] readFile(String fileName) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> Files.readAllBytes(<span class="keyword">new</span> File(fileName).toPath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(String destPath, <span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File dest = <span class="keyword">new</span> File(destPath);</span><br><span class="line">        <span class="keyword">if</span> (!dest.exists()) &#123;</span><br><span class="line">            dest.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        Files.write(dest.toPath(), bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CookieUtils"><a href="#CookieUtils" class="headerlink" title="CookieUtils"></a>CookieUtils</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Cookie 工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CookieUtils<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到Cookie的值, 不编码</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cookieName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCookieValue</span><span class="params">(HttpServletRequest request, String cookieName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getCookieValue(request, cookieName, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到Cookie的值,</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cookieName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCookieValue</span><span class="params">(HttpServletRequest request, String cookieName, <span class="keyword">boolean</span> isDecoder)</span> </span>&#123;</span><br><span class="line">Cookie[] cookieList = request.getCookies();</span><br><span class="line"><span class="keyword">if</span> (cookieList == <span class="keyword">null</span> || cookieName == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String retValue = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cookieList.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (cookieList[i].getName().equals(cookieName)) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDecoder) &#123;</span><br><span class="line">retValue = URLDecoder.decode(cookieList[i].getValue(), <span class="string">"UTF-8"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">retValue = cookieList[i].getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">logger.error(<span class="string">"Cookie Decode Error."</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到Cookie的值,</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cookieName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCookieValue</span><span class="params">(HttpServletRequest request, String cookieName, String encodeString)</span> </span>&#123;</span><br><span class="line">Cookie[] cookieList = request.getCookies();</span><br><span class="line"><span class="keyword">if</span> (cookieList == <span class="keyword">null</span> || cookieName == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String retValue = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cookieList.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (cookieList[i].getName().equals(cookieName)) &#123;</span><br><span class="line">retValue = URLDecoder.decode(cookieList[i].getValue(), encodeString);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">logger.error(<span class="string">"Cookie Decode Error."</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成cookie，并指定编码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request 请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response 响应</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cookieName name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cookieValue value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encodeString 编码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setCookie</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, String encodeString)</span> </span>&#123;</span><br><span class="line">setCookie(request,response,cookieName,cookieValue,<span class="keyword">null</span>,encodeString, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成cookie，并指定生存时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request 请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response 响应</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cookieName name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cookieValue value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cookieMaxAge 生存时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setCookie</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, Integer cookieMaxAge)</span> </span>&#123;</span><br><span class="line">setCookie(request,response,cookieName,cookieValue,cookieMaxAge,<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置cookie，不指定httpOnly属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setCookie</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, Integer cookieMaxAge, String encodeString)</span> </span>&#123;</span><br><span class="line">setCookie(request,response,cookieName,cookieValue,cookieMaxAge,encodeString, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置Cookie的值，并使其在指定时间内生效</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cookieMaxAge</span></span><br><span class="line"><span class="comment"> *            cookie生效的最大秒数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setCookie</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, Integer cookieMaxAge, String encodeString, Boolean httpOnly)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isBlank(encodeString)) &#123;</span><br><span class="line">encodeString = <span class="string">"utf-8"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cookieValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">cookieValue = <span class="string">""</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cookieValue = URLEncoder.encode(cookieValue, encodeString);</span><br><span class="line">&#125;</span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(cookieName, cookieValue);</span><br><span class="line"><span class="keyword">if</span> (cookieMaxAge != <span class="keyword">null</span> &amp;&amp; cookieMaxAge &gt; <span class="number">0</span>)</span><br><span class="line">cookie.setMaxAge(cookieMaxAge);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != request)<span class="comment">// 设置域名的cookie</span></span><br><span class="line">cookie.setDomain(getDomainName(request));</span><br><span class="line">cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(httpOnly != <span class="keyword">null</span>) &#123;</span><br><span class="line">cookie.setHttpOnly(httpOnly);</span><br><span class="line">&#125;</span><br><span class="line">response.addCookie(cookie);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">logger.error(<span class="string">"Cookie Encode Error."</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到cookie的域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">getDomainName</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">String domainName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">String serverName = request.getRequestURL().toString();</span><br><span class="line"><span class="keyword">if</span> (serverName == <span class="keyword">null</span> || serverName.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">domainName = <span class="string">""</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">serverName = serverName.toLowerCase();</span><br><span class="line">serverName = serverName.substring(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> end = serverName.indexOf(<span class="string">"/"</span>);</span><br><span class="line">serverName = serverName.substring(<span class="number">0</span>, end);</span><br><span class="line"><span class="keyword">final</span> String[] domains = serverName.split(<span class="string">"\\."</span>);</span><br><span class="line"><span class="keyword">int</span> len = domains.length;</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">// www.xxx.com.cn</span></span><br><span class="line">domainName = domains[len - <span class="number">3</span>] + <span class="string">"."</span> + domains[len - <span class="number">2</span>] + <span class="string">"."</span> + domains[len - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt;= <span class="number">3</span> &amp;&amp; len &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// xxx.com or xxx.cn</span></span><br><span class="line">domainName = domains[len - <span class="number">2</span>] + <span class="string">"."</span> + domains[len - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">domainName = serverName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (domainName != <span class="keyword">null</span> &amp;&amp; domainName.indexOf(<span class="string">":"</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">String[] ary = domainName.split(<span class="string">"\\:"</span>);</span><br><span class="line">domainName = ary[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> domainName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"auth"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthService authService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"accredit"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resp&lt;Object&gt; <span class="title">accredit</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span>String username, @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span>String password, HttpServletRequest request, HttpServletResponse response)</span>&#123;</span><br><span class="line"></span><br><span class="line">        String token = <span class="keyword">this</span>.authService.accredit(username, password);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(token)) &#123;</span><br><span class="line">            <span class="comment">// 放入cookie中</span></span><br><span class="line">            CookieUtils.setCookie(request, response, <span class="keyword">this</span>.properties.getCookieName(), token, <span class="keyword">this</span>.properties.getExpire() * <span class="number">60</span>);</span><br><span class="line">            <span class="keyword">return</span> Resp.ok(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MemberException(<span class="string">"用户名或者密码错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserClient userClient;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">accredit</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.根据用户名和密码查询</span></span><br><span class="line">        User user = userClient.queryUser(username, password);</span><br><span class="line">        <span class="comment">//2.判断user</span></span><br><span class="line">        <span class="keyword">if</span> (user==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.jwtUtils生成jwt类型的token</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"id"</span>, user.getId());</span><br><span class="line">            map.put(<span class="string">"username"</span>, user.getUsername());</span><br><span class="line">            <span class="keyword">return</span> JwtUtils.generateToken(map, <span class="keyword">this</span>.properties.getPrivateKey(),<span class="keyword">this</span>.properties.getExpire());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p><a href="https://medium.com/@ddarie/jwt-authentication-with-sha-and-rsa-307e272f913f" target="_blank" rel="noopener">JWT Authentication with SHA and RSA </a></p><p><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="noopener">什么是 JWT – JSON WEB TOKEN</a></p><p><a href="https://www.cnblogs.com/hubavyn/p/4759688.html" target="_blank" rel="noopener">REST有状态和无状态的理解</a></p><p><a href="https://segmentfault.com/a/1190000019457890?utm_source=sf-related" target="_blank" rel="noopener">详解Cookie,Session,Token</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 业务杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务杂谈 </tag>
            
            <tag> 无状态和有状态登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data Jpa</title>
      <link href="/2020/08/01/2.Spring%20Data%20JPA/"/>
      <url>/2020/08/01/2.Spring%20Data%20JPA/</url>
      
        <content type="html"><![CDATA[<h1 id="前提说明"><a href="#前提说明" class="headerlink" title="前提说明"></a>前提说明</h1><p>公司用到的持久层框架是Spring Data Jpa，并且规定数据库不能使用外键，阿里巴巴也有这样的规范，原因可以参考：</p><blockquote><p><a href="https://draveness.me/whys-the-design-database-foreign-key/" target="_blank" rel="noopener">为什么数据库不使用外键</a></p></blockquote><p>所以，以下所有的数据库表都是自己创建并且不设置外键，不让Jpa自动生成表的配置如下</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jpa.hibernate.ddl-auto</span>=<span class="string">none</span></span><br></pre></td></tr></table></figure><h1 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`jpa_customer`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`cust_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`cust_source`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`cust_industry`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`cust_level`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`cust_address`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`cust_phone`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">17</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`jpa_orders`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`customer_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`order_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">30</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`jpa_teacher`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`teacher_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`jpa_teacher`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`teacher_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`stu_teacher`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`stu_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`teacher_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`FK4twafufgi21p02isb1mt8hrdr`</span> (<span class="string">`teacher_id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`FKe8gx6dtm78imkd78p6mj8nh8o`</span> (<span class="string">`stu_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`FK4twafufgi21p02isb1mt8hrdr`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`teacher_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`jpa_teacher`</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`FKe8gx6dtm78imkd78p6mj8nh8o`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`stu_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`jpa_student`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">8</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure><h1 id="单向一对多"><a href="#单向一对多" class="headerlink" title="单向一对多"></a>单向一对多</h1><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"jpa_customer"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long custId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_source"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_industry"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custIndustry;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_level"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custLevel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_address"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custAddress;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_phone"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custPhone;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对的一方操作影响多的一方，需要配置级联操作</span></span><br><span class="line">    <span class="meta">@OneToMany</span>(cascade = CascadeType.ALL)</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"customer_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"jpa_orders"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"order_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"customer_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long customerId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback</span>(<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建顾客</span></span><br><span class="line">    Customer c = <span class="keyword">new</span> Customer();</span><br><span class="line">    c.setCustName(<span class="string">"张三"</span>);</span><br><span class="line">    c.setCustLevel(<span class="string">"VIP客户"</span>);</span><br><span class="line">    c.setCustSource(<span class="string">"网络"</span>);</span><br><span class="line">    c.setCustIndustry(<span class="string">"商业办公"</span>);</span><br><span class="line">    c.setCustAddress(<span class="string">"海淀区"</span>);</span><br><span class="line">    c.setCustPhone(<span class="string">"010-84389340"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建订单</span></span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setOrderName(<span class="string">"order1"</span>);</span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setOrderName(<span class="string">"order2"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置关联关系</span></span><br><span class="line">    c.getOrders().add(order1);</span><br><span class="line">    c.getOrders().add(order2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存</span></span><br><span class="line">    customerRepository.save(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback</span>(<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Customer customer = customerRepository.getOne(<span class="number">2l</span>);</span><br><span class="line">    customer.getOrders().get(<span class="number">0</span>).setOrderName(<span class="string">"order10010"</span>);</span><br><span class="line">    customerRepository.save(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>如果想在一的一方的列表中删除多的一方的同时，实际删除多的一方的数据，必须加上orphanRemoval = true，否则会将多的一方的表中对应逻辑外键置为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OneToMany</span>(cascade = CascadeType.ALL, orphanRemoval = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"customer_id"</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;Order&gt; orders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback</span>(<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Customer customer = customerRepository.getOne(<span class="number">2l</span>);</span><br><span class="line">    Order order = customer.getOrders().get(<span class="number">0</span>);</span><br><span class="line">    customer.getOrders().remove(order);</span><br><span class="line">    customerRepository.save(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback</span>(<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Customer customer = customerRepository.getOne(<span class="number">2l</span>);</span><br><span class="line">    System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">    System.out.println(customer);</span><br><span class="line">    System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">&#125;</span><br><span class="line">结果如下：</span><br><span class="line">Customer(custId=<span class="number">3</span>, custName=张三, custSource=网络, custIndustry=商业办公, custLevel=VIP客户, custAddress=昌平区北七家镇, custPhone=<span class="number">010</span>-<span class="number">84389340</span>, orders=[Order(id=<span class="number">3</span>, orderName=order1, customerId=<span class="number">3</span>), Order(id=<span class="number">4</span>, orderName=order2, customerId=<span class="number">3</span>)])</span><br></pre></td></tr></table></figure><h1 id="单向多对一"><a href="#单向多对一" class="headerlink" title="单向多对一"></a>单向多对一</h1><p>级联保存、级联删除等之类的属性在多对一的关系时不需要设置的，因为订单删除或者添加修改，都不会影响到顾客的状态，不能说因为订单没有了就没有顾客了，顾客可以有多个订单，所以对于订单只有级联查找操作</p><h2 id="Entity-1"><a href="#Entity-1" class="headerlink" title="Entity"></a>Entity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"jpa_customer"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long custId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_source"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_industry"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custIndustry;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_level"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custLevel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_address"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custAddress;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_phone"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custPhone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"jpa_orders"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"order_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"customer_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long customerId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"customer_id"</span>,insertable = <span class="keyword">false</span>,updatable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Optional&lt;Order&gt; optional = orderRepository.findById(<span class="number">3</span>);</span><br><span class="line">    Order order = optional.get();</span><br><span class="line">    System.out.println(<span class="string">"=========================="</span>);</span><br><span class="line">    System.out.println(order);</span><br><span class="line">    System.out.println(<span class="string">"=========================="</span>);</span><br><span class="line">&#125;</span><br><span class="line">结果如下：</span><br><span class="line">Order(id=<span class="number">3</span>, orderName=order1, customerId=<span class="number">3</span>, customer=Customer(custId=<span class="number">3</span>, custName=张三, custSource=网络, custIndustry=商业办公, custLevel=VIP客户, custAddress=昌平区北七家镇, custPhone=<span class="number">010</span>-<span class="number">84389340</span>))</span><br></pre></td></tr></table></figure><h1 id="双向一对多"><a href="#双向一对多" class="headerlink" title="双向一对多"></a>双向一对多</h1><p>因为一和多的一方都有彼此，而lombok中的toString方法中都调用了对方，这样会造成循环引用造成栈溢出，所以应该手动重写一方的toString方法</p><p>在不配置外键的情况下，逻辑外键只有一的一方才会维护，所以不能一的一方不能用mappedby放弃维护外键</p><h2 id="Entity-2"><a href="#Entity-2" class="headerlink" title="Entity"></a>Entity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"jpa_customer"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long custId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_source"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_industry"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custIndustry;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_level"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custLevel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_address"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custAddress;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"cust_phone"</span>)</span><br><span class="line">    <span class="keyword">private</span> String custPhone;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(cascade = CascadeType.ALL, orphanRemoval = <span class="keyword">true</span>)</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"customer_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"jpa_orders"</span>)</span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Order&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", orderName='"</span> + orderName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", customerId="</span> + customerId +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"order_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"customer_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long customerId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"customer_id"</span>,insertable = <span class="keyword">false</span>,updatable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback</span>(<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建顾客</span></span><br><span class="line">    Customer c = <span class="keyword">new</span> Customer();</span><br><span class="line">    c.setCustName(<span class="string">"李四"</span>);</span><br><span class="line">    c.setCustLevel(<span class="string">"VIP客户"</span>);</span><br><span class="line">    c.setCustSource(<span class="string">"网络"</span>);</span><br><span class="line">    c.setCustIndustry(<span class="string">"商业办公"</span>);</span><br><span class="line">    c.setCustAddress(<span class="string">"海淀区"</span>);</span><br><span class="line">    c.setCustPhone(<span class="string">"010-84389340"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建订单</span></span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setOrderName(<span class="string">"订单11"</span>);</span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setOrderName(<span class="string">"订单22"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置关联关系</span></span><br><span class="line">    c.getOrders().add(order1);</span><br><span class="line">    c.getOrders().add(order2);</span><br><span class="line">    order1.setCustomer(c);</span><br><span class="line">    order2.setCustomer(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存</span></span><br><span class="line">    customerRepository.save(c);</span><br><span class="line">    orderRepository.save(order1);</span><br><span class="line">    orderRepository.save(order2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback</span>(<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由一查询多</span></span><br><span class="line">    Customer customer = customerRepository.getOne(<span class="number">3l</span>);</span><br><span class="line">    <span class="comment">//由多查询一</span></span><br><span class="line">    Order order = orderRepository.getOne(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">    System.out.println(customer);</span><br><span class="line">    System.out.println(order);</span><br><span class="line">    System.out.println(order.getCustomer());</span><br><span class="line">    System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">&#125;</span><br><span class="line">结果如下：</span><br><span class="line">Customer(custId=<span class="number">3</span>, custName=张三, custSource=网络, custIndustry=商业办公, custLevel=VIP客户, custAddress=昌平区北七家镇, custPhone=<span class="number">010</span>-<span class="number">84389340</span>, orders=[Order&#123;id=<span class="number">3</span>, orderName=<span class="string">'order1'</span>, customerId=<span class="number">3</span>&#125;, Order&#123;id=<span class="number">4</span>, orderName=<span class="string">'order2'</span>, customerId=<span class="number">3</span>&#125;])</span><br><span class="line">Order&#123;id=<span class="number">3</span>, orderName=<span class="string">'order1'</span>, customerId=<span class="number">3</span>&#125;</span><br><span class="line">Customer(custId=<span class="number">3</span>, custName=张三, custSource=网络, custIndustry=商业办公, custLevel=VIP客户, custAddress=昌平区北七家镇, custPhone=<span class="number">010</span>-<span class="number">84389340</span>, orders=[Order&#123;id=<span class="number">3</span>, orderName=<span class="string">'order1'</span>, customerId=<span class="number">3</span>&#125;, Order&#123;id=<span class="number">4</span>, orderName=<span class="string">'order2'</span>, customerId=<span class="number">3</span>&#125;])</span><br></pre></td></tr></table></figure><h2 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback</span>(<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由一修改多的一方</span></span><br><span class="line">    Customer customer = customerRepository.getOne(<span class="number">3l</span>);</span><br><span class="line">    customer.getOrders().get(<span class="number">0</span>).setOrderName(<span class="string">"order10010"</span>);</span><br><span class="line">    customerRepository.save(customer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由多修改一的一方</span></span><br><span class="line">    Order order = orderRepository.getOne(<span class="number">4</span>);</span><br><span class="line">    order.getCustomer().setCustName(<span class="string">"王五"</span>);</span><br><span class="line">    orderRepository.save(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Rollback</span>(<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Customer customer = customerRepository.getOne(<span class="number">3l</span>);</span><br><span class="line">    <span class="comment">//由一删除多的一方</span></span><br><span class="line">    Order order = customer.getOrders().get(<span class="number">0</span>);</span><br><span class="line">    customer.getOrders().remove(order);</span><br><span class="line">    orderRepository.delete(order);</span><br><span class="line">    customerRepository.save(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双向多对多"><a href="#双向多对多" class="headerlink" title="双向多对多"></a>双向多对多</h1><h2 id="Entity-3"><a href="#Entity-3" class="headerlink" title="Entity"></a>Entity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"jpa_student"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"stu_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String stuName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="meta">@JoinTable</span>(name = <span class="string">"stu_teacher"</span>,</span><br><span class="line">            <span class="comment">//当前对象在中间表的外键</span></span><br><span class="line">            joinColumns = <span class="meta">@JoinColumn</span>(name = <span class="string">"stu_id"</span>),</span><br><span class="line">            <span class="comment">//对方对象在中间表的外键</span></span><br><span class="line">            inverseJoinColumns = <span class="meta">@JoinColumn</span>(name = <span class="string">"teacher_id"</span>))</span><br><span class="line">    <span class="comment">//关系维护端，负责多对多关系的绑定和解除</span></span><br><span class="line">    <span class="comment">//@JoinTable注解的name属性指定关联表的名字，joinColumns指定外键的名字，关联到关系维护端(Student)</span></span><br><span class="line">    <span class="comment">//inverseJoinColumns指定外键的名字，要关联的关系被维护端(Teacher)</span></span><br><span class="line">    <span class="comment">//主表就是关系维护端对应的表，从表就是关系被维护端对应的表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Teacher&gt; teachers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"jpa_teacher"</span>)</span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Teacher&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", teacherName='"</span> + teacherName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"teacher_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String teacherName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只需要设置mappedBy="teachers"表明Teacher实体是关系被维护端就可以了</span></span><br><span class="line">    <span class="comment">//级联保存、级联删除等之类的属性在多对多关系中是不需要设置</span></span><br><span class="line">    <span class="comment">//不能说老师离职,学生就没有其他老师了,学生可以有多个老师</span></span><br><span class="line">    <span class="meta">@ManyToMany</span>(mappedBy = <span class="string">"teachers"</span>)</span><br><span class="line">    List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加-2"><a href="#添加-2" class="headerlink" title="添加"></a>添加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback</span>(<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建学生和老师</span></span><br><span class="line">    Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">    Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">    s1.setStuName(<span class="string">"student1"</span>);</span><br><span class="line">    s2.setStuName(<span class="string">"student2"</span>);</span><br><span class="line">    Teacher t1 = <span class="keyword">new</span> Teacher();</span><br><span class="line">    Teacher t2 = <span class="keyword">new</span> Teacher();</span><br><span class="line">    t1.setTeacherName(<span class="string">"teacher1"</span>);</span><br><span class="line">    t2.setTeacherName(<span class="string">"teacher2"</span>);</span><br><span class="line">    <span class="comment">//学生关联老师</span></span><br><span class="line">    s1.getTeachers().add(t1);</span><br><span class="line">    s1.getTeachers().add(t2);</span><br><span class="line">    s2.getTeachers().add(t1);</span><br><span class="line">    s2.getTeachers().add(t2);</span><br><span class="line">    <span class="comment">//保存</span></span><br><span class="line">    studentRepository.save(s1);</span><br><span class="line">    studentRepository.save(s2);</span><br><span class="line">    teacherRepository.save(t1);</span><br><span class="line">    teacherRepository.save(t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找-3"><a href="#查找-3" class="headerlink" title="查找"></a>查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback</span>(<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = studentRepository.getOne(<span class="number">1l</span>);</span><br><span class="line">    System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">    System.out.println(student);</span><br><span class="line">    System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改-2"><a href="#修改-2" class="headerlink" title="修改"></a>修改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback</span>(<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = studentRepository.getOne(<span class="number">1l</span>);</span><br><span class="line">    System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">    Teacher teacher = student.getTeachers().get(<span class="number">0</span>);</span><br><span class="line">    teacher.setTeacherName(<span class="string">"teacher10086"</span>);</span><br><span class="line">    studentRepository.save(student);</span><br><span class="line">    System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback</span>(<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = studentRepository.getOne(<span class="number">1l</span>);</span><br><span class="line">    System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">    student.getTeachers().remove(<span class="number">0</span>);</span><br><span class="line">    studentRepository.save(student);</span><br><span class="line">    System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring Data Jpa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Data Jpa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2020/08/01/3.Git/"/>
      <url>/2020/08/01/3.Git/</url>
      
        <content type="html"><![CDATA[<p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200729140833.png" alt="Git常用命令流程图"></p><hr><h1 id="本地库操作"><a href="#本地库操作" class="headerlink" title="本地库操作"></a>本地库操作</h1><h2 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init 将当前的目录变为git可以管理的仓库，会出现.git文件</span><br><span class="line">git add . 将当前目录内容添加到暂存区</span><br><span class="line">git commit -m <span class="string">"提交信息"</span> 将暂存区内容提交到本地库</span><br><span class="line">git status 查看仓库当前状态</span><br><span class="line">git diff &lt;file&gt; 查看某个文件的修改内容</span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline 查看日志(简化版本)</span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>HEAD表示当前版本 HEAD^表示上一个版本 上上一个版本就是HEAD^^，以此类推…</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^ 暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响</span><br><span class="line">git reflog 记录每一次的命令</span><br></pre></td></tr></table></figure><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>文件没有add情况下回退,这种情况下也可以手动修改代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure><p>文件add完的情况下回退</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD readme.txt </span><br><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>删完发现删错了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- . 拉取上一次提交后的状态</span><br></pre></td></tr></table></figure><p>本地删除文件，然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add . 或者 git rm LCENSE</span><br><span class="line">git commit -m <span class="string">"删除LCENSE"</span></span><br><span class="line"></span><br><span class="line">git rm &lt;file&gt; Git中移除某个文件</span><br><span class="line">git rm --cached &lt;file&gt; 直接从暂存区删除文件，工作区则不做出改变</span><br></pre></td></tr></table></figure><h1 id="远程库操作"><a href="#远程库操作" class="headerlink" title="远程库操作"></a>远程库操作</h1><h2 id="先有本地库，关联远程库"><a href="#先有本地库，关联远程库" class="headerlink" title="先有本地库，关联远程库"></a>先有本地库，关联远程库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote 查看远程库信息</span><br><span class="line">git remote -v 查看更详细的信息</span><br><span class="line">git remote add origin git@github.com:szx9898/git_test.git 配置名为origin的远程库</span><br><span class="line">git push -u origin master 第一次推送到远程库</span><br></pre></td></tr></table></figure><p>​    由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master 或者 git push 默认推送名为origin的master分支上</span><br></pre></td></tr></table></figure><h2 id="先有远程库，克隆到本地"><a href="#先有远程库，克隆到本地" class="headerlink" title="先有远程库，克隆到本地"></a>先有远程库，克隆到本地</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:szx9898/git_test.git</span><br></pre></td></tr></table></figure><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev origin/dev 创建远程origin的dev分支到本地</span><br><span class="line">git checkout -b dev/git switch -c dev </span><br><span class="line">创建并切换分支到dev，相当于创建分支：git branch dev和切换分支：git checkout dev/git switch master</span><br><span class="line">git branch 查看所有分支，当前分支前面会有*号</span><br></pre></td></tr></table></figure><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git checkout master 由dev切换到master</span><br><span class="line"></span><br><span class="line">git merge dev 名为dev分支工作成果合并到master，指定分支合并到当前分支</span><br><span class="line">当有冲突时，git status会显示冲突的文件，手动修改后需要再git add 并且 git commit才算合并成功</span><br><span class="line"></span><br><span class="line">git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev </span><br><span class="line">禁用Fast forward，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息，因为每次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</span><br><span class="line"></span><br><span class="line">git branch -d dev 合并完成后删除分支dev</span><br><span class="line">git branch -D dev 删除未合并的分支</span><br><span class="line">git <span class="built_in">log</span> --graph 查看分支合并图</span><br></pre></td></tr></table></figure><h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><p>当master分支上出现了bug，而你此时工作的dev分支上的任务只进行到一半无法提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git stash 隐藏当前工作</span><br><span class="line">git checkout master 切换到主分支</span><br><span class="line">git checkout -b issue 在master分支上创建临时分支issue，修复bug</span><br><span class="line">修改bug操作...</span><br><span class="line">git commit -m <span class="string">"fixed bug"</span></span><br><span class="line">git checkout master 再切换到主分支</span><br><span class="line">git merge --no-ff -m <span class="string">"merged bug fix"</span> issue 合并issue分支</span><br><span class="line">git checkout dev 切换到dev分支</span><br><span class="line"></span><br><span class="line">git stash list </span><br><span class="line">git stash apply 内容恢复，stash内容不删除</span><br><span class="line">git stash pop 内容恢复，stash内容删除</span><br></pre></td></tr></table></figure><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">切换到需要打标签的分支上，然后：</span><br><span class="line">git tag v1.0</span><br><span class="line">git tag 查看所有标签，默认标签是打在最新提交的commit上的</span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br><span class="line">git tag v0.9 f52c633 给某次提交贴标签</span><br><span class="line">git show v1.0 查看标签信息</span><br><span class="line">git tag -d v0.1 标签删除</span><br><span class="line">git push origin v1.0 推送某个标签到远程</span><br><span class="line">git push origin --tags 推送全部标签</span><br><span class="line">删除远程的标签：</span><br><span class="line">git tag -d v0.9 先删除本地</span><br><span class="line">git push origin :refs/tags/v0.9 删除远程标签</span><br></pre></td></tr></table></figure><blockquote><p>文章参考:<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰Git教程</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收算法(理论)</title>
      <link href="/2020/08/01/1.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95(%E7%90%86%E8%AE%BA)/"/>
      <url>/2020/08/01/1.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95(%E7%90%86%E8%AE%BA)/</url>
      
        <content type="html"><![CDATA[<p><strong>垃圾：指运行程序中没有任何指针指向的对象</strong></p><h1 id="标记垃圾"><a href="#标记垃圾" class="headerlink" title="标记垃圾"></a>标记垃圾</h1><h2 id="引用计数算法-Java未使用"><a href="#引用计数算法-Java未使用" class="headerlink" title="引用计数算法(Java未使用)"></a>引用计数算法(Java未使用)</h2><p>​    对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1.只要对象A的引用计数器的值为0，即表示对象不可能再被使用，可进行回收</p><p><strong>优点：</strong>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性</p><p><strong>缺点：</strong></p><ul><li>需要单独的计数器，增加了空间的开销</li><li>每次赋值都需要更新计数器，增加了时间开销。</li><li><strong>无法处理循环引用的情况</strong>。这是一条致命缺陷导致在Java的垃圾回收器中没有使用这类算法</li></ul><h2 id="可达性分析-Java使用"><a href="#可达性分析-Java使用" class="headerlink" title="可达性分析(Java使用)"></a>可达性分析(Java使用)</h2><p>从GCRoots对象向下搜索，一个对象到GCRoots没有任何引用链相连，此对象不可用</p><p><strong>可做GCRoots的对象：</strong></p><ul><li>虚拟机栈/本地方法栈中引用的对象</li><li>方法区中的类静态属性引用的对象。</li><li>方法区中常量引用的对象</li><li>所有被同步锁synchronized持有的对象</li></ul><p><strong>注意：</strong>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在个能保障一致性的快照（引用不发生变化）中进行。这点不满足的话分析结果的准确性就无法保证</p><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><p>​    当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”</p><p>​    finialize()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等等</p><p><strong>1.永远不要主动调用某个对象的 finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：</strong></p><ul><li>在 finalize()时可能会导致对象复活。</li><li>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下若不发生GC，则fina1ize（方法将没有执行机会。</li><li>一个糟糕的fina1ize()会严重影响GC的性能。</li></ul><p><strong>2.由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态:</strong></p><ul><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li><li>不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。</li></ul><p>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><p><strong>3.判定一个对象objA是否可回收，至少要经历两次标记过程：</strong></p><ol><li><p>如果对象objA到GCRoots没有引用链，则进行第一次标记</p></li><li><p>进行筛选，判断此对象是否有必要执行finalize()方法</p><p>①如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，obiA被判定为不可触及的</p><p>②如果对象objA重写了finalize()方法，且还未执行过，那么objA方会被插入到F- Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</p><p>③finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F- Queue队列中的对象进行第二次标记。如果objA在finalize（方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，obA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下， finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</p></li></ol><h1 id="清除垃圾"><a href="#清除垃圾" class="headerlink" title="清除垃圾"></a>清除垃圾</h1><h2 id="标记-清除-Mark-Sweep-算法"><a href="#标记-清除-Mark-Sweep-算法" class="headerlink" title="标记-清除(Mark-Sweep)算法"></a>标记-清除(Mark-Sweep)算法</h2><p><strong>标记</strong>：标记的是非垃圾对象，一般在对象的Header中记录为可达对象。</p><p><strong>清除</strong>：没有被标记的就是垃圾，再次遍历时就会被清除。</p><p>注意：清除是指将需要清除的对象地址保存在空闲地址列表中，下次有新对象时需要加载时，判断垃圾位置空间是否足够，如果够，就存放</p><p><strong>缺点</strong>：</p><ol><li><p>效率不算高</p></li><li><p>在进行GC的时候，需要停止整个应用程序，导致用户体验差</p></li><li><p>清理后内存空间不连续，产生内存碎片，需要维护一个空闲列表</p></li></ol><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805113536.png" style="zoom: 67%;" /><h2 id="复制-Copying-算法"><a href="#复制-Copying-算法" class="headerlink" title="复制(Copying)算法"></a>复制(Copying)算法</h2><p>从根节点开始遍历，凡是能够遍历到的对象(即可达对象)，直接将对象放到跟它大小一致的内存空间中，复制时就将对象紧密排列整齐，然后将之前的空间删除，这样就得到内存连续的空间。</p><p><strong>优点：</strong></p><ol><li><p>没有标记和清除的过程，实现简单，运行高效</p></li><li><p>复制后空间连续，没有内存碎片</p></li></ol><p><strong>缺点：</strong></p><ol><li><p>需要两倍的内存空间</p></li><li><p>对于G1这种拆分成大量region的GC，复制不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销都不小</p></li></ol><p><strong>特别：</strong>如果系统垃圾很多，复制算法需要复制的存活对象数量不会太大，或者说非常低才行</p><p><strong>应用场景：</strong>新生代的from区和to区，存活对象少，垃圾对象多</p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805113801.png" style="zoom:67%;" /><h2 id="标记-压缩-整理-Mark-Compact-算法"><a href="#标记-压缩-整理-Mark-Compact-算法" class="headerlink" title="标记-压缩/整理(Mark-Compact)算法"></a>标记-压缩/整理(Mark-Compact)算法</h2><p>第一阶段和标记-清除的第一阶段相同，第二阶段将存活对象压缩到内存另一端，按顺序排放，之后清理边界外所有空间</p><p><strong>缺点：</strong></p><ol><li><p>效率低于复制算法</p></li><li><p>移动对象时，如果被其他对象引用，还需调整引用地址</p></li><li><p>移动过程中会暂停用户应用程序</p></li></ol><p><strong>优点：</strong>内存连续</p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805113858.png" style="zoom:67%;" /><p><img src="https://typora-picgo-download.oss-cn-beijing.aliyuncs.com/img/20200805113915.png" alt="三种算法对比"></p><hr><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p><strong>年轻代：</strong>区域小，对象周期短、存活率低，回收频繁——-&gt;<strong>复制算法</strong></p><p><strong>老年代：</strong>区域大，对象周期长、存活率高，回收不及年轻代频繁——-&gt;<strong>标记-清除/标记-整理混合使用</strong></p><h2 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h2><p>​    如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p><p>​    总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p><p>​    <strong>缺点：</strong>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成 本上升，造成系统吞吐量的下降。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>以下所有都是在引用关系还在的情况</p><h2 id="强引用-StrongReference"><a href="#强引用-StrongReference" class="headerlink" title="强引用(StrongReference)"></a>强引用(StrongReference)</h2><p>Object obj = new Object(),无论任何情况下，<strong>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</strong></p><h2 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用(SoftReference)"></a>软引用(SoftReference)</h2><p>在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。<strong>如果这次回收后还没有足够的内存，才会抛出内存溢出异常</strong></p><h2 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用(WeakReference)"></a>弱引用(WeakReference)</h2><p>被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，<strong>无论内存空间是否足够，都会回收掉被弱引用关联的对象</strong></p><h2 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用(PhantomReference)"></a>虚引用(PhantomReference)</h2><p>​    一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</p><p>​    虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReferenceDemo obj;</span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;ReferenceDemo&gt; referenceQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> CheckRefQueue();</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置为守护线程，没有非守护线程运行，守护线程也就结束</span></span><br><span class="line">        t.start();</span><br><span class="line">        phantomReference();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"调用当前类的finalize()方法"</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;<span class="comment">//复活</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (referenceQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;ReferenceDemo&gt; objt = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;ReferenceDemo&gt;) referenceQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"追踪垃圾回收过程：ReferenceDemo实例被GC了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虚引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">phantomReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj = <span class="keyword">new</span> ReferenceDemo();</span><br><span class="line">        referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;ReferenceDemo&gt;();</span><br><span class="line">        PhantomReference&lt;ReferenceDemo&gt; rf = <span class="keyword">new</span> PhantomReference&lt;&gt;(obj, referenceQueue);</span><br><span class="line">        System.out.println(rf.get());</span><br><span class="line">        obj = <span class="keyword">null</span>;<span class="comment">//销毁强引用</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"第一次GC："</span>);</span><br><span class="line">        <span class="comment">//暂停一会线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"obj is null"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"obj 可用"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        obj = <span class="keyword">null</span>;<span class="comment">//再次销毁强引用</span></span><br><span class="line">        System.gc();<span class="comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span></span><br><span class="line">        System.out.println(<span class="string">"第二次GC："</span>);</span><br><span class="line">        <span class="comment">//暂停一会线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"obj is null"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"obj 可用"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//内存不够也不回收</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">strongReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuffer s1 = <span class="keyword">new</span> StringBuffer(<span class="string">"xxx"</span>);</span><br><span class="line">        StringBuffer s2 = s1;</span><br><span class="line">        s1 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//暂停一会线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内存不够再回收</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Object obj = new Object();//声明强引用</span></span><br><span class="line">        <span class="comment">//SoftReference&lt;Object&gt; sf = new SoftReference&lt;&gt;(obj);//创建软引用</span></span><br><span class="line">        <span class="comment">//obj = null;//销毁强引用，只剩软引用</span></span><br><span class="line">        SoftReference&lt;String&gt; sf = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> String(<span class="string">"123"</span>));<span class="comment">//相当于上面三行</span></span><br><span class="line">        System.out.println(sf.get());<span class="comment">//从软引用中获取强引用对象</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"内存资源足够 After GC:"</span>);</span><br><span class="line">        System.out.println(sf.get());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"让系统资源紧张:"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(sf.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内存够也回收</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weakReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WeakReference&lt;String&gt; sf = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> String(<span class="string">"123"</span>));</span><br><span class="line">        System.out.println(sf.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"内存资源足够 After GC:"</span>);</span><br><span class="line">        System.out.println(sf.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><h2 id="内存溢出-OOM"><a href="#内存溢出-OOM" class="headerlink" title="内存溢出(OOM)"></a>内存溢出(OOM)</h2><p>​    没有空闲内存，并且垃圾收集器无法提供更多的内存</p><h2 id="内存泄漏-Memory-Leak"><a href="#内存泄漏-Memory-Leak" class="headerlink" title="内存泄漏(Memory Leak)"></a>内存泄漏(Memory Leak)</h2><p>​    严格来说，只有对象不会再被程序调用了，但是GC又无法回收它们的情况，才叫内存泄漏。</p><p>​    但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长（<strong>比如本来在方法内部使用的变量定义到外部，甚至加上static导致变量的生命周期变长</strong>）甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</p><p><strong>举例：</strong></p><ol><li><p>单例模式</p><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p></li><li><p>一些提供close的资源未关闭导致内存泄漏</p><p>数据库连接(dataSource. getconnection()，网络连接(socket)和io连接必须手动cose，否则是不能被回收的。</p></li></ol><h2 id="安全点-SafePoint"><a href="#安全点-SafePoint" class="headerlink" title="安全点(SafePoint)"></a>安全点(SafePoint)</h2><p>​    程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（ Savepoint）”。</p><p>​    Safe point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择些执行时间较长的指令作为 Safe point，如方法调用、循环跳转和异常跳转等。</p><p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></p><ul><li><p>抢先式中断：（目前没有虚拟机采用了）</p><ul><li>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li></ul></li><li><p>主动式中断：</p><ul><li>设置一个中断标志，各个线程运行到 Safe point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起</li></ul></li></ul><h2 id="安全区域-Safe-Region"><a href="#安全区域-Safe-Region" class="headerlink" title="安全区域(Safe Region)"></a>安全区域(Safe Region)</h2><p>​    Savepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的 Savepoint。但是，程序“不执行”的时候呢？例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（ Safe region）来解决。</p><p>​    安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把 Safe Region看做是被扩展了的 Safepoint</p><p><strong>实际执行：</strong></p><ul><li><p>当线程运行到 Safe Region的代码时，首先标识已经进入了 Safe region，如果这段时间内发生GC，JVM会忽略标识为 Safe region状态的线程</p></li><li><p>当线程即将离开 Safe Region时，会检查JWM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe region的信号为止；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM&amp;GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
